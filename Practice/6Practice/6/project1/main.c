// 15 вариант , ÷”ић
//  R/t --> T Ц передача (символы из пам€ти ћ  передаютс€ по последовательному порту на Virtual Terminal).
//	K	--> 1 (режим работы) SM0 = 0, SM1 = 1
//	S	--> 19.2 (кб/сек)	
//	XX	--> 50h (мне это не надо, так как € на выдаче пиздюлей)
//	N	--> 15	(байт, т.е. 15 символов)

#include <8051.h>

//
//void sleep(int x) { // функц€ дл€ вызова таймера, где передача 1 = 10 мсек (изначально было 100 мс)
//	int i;
//	tmod = 0x01; // 16-битный таймер/счЄтчик. УthxФ и УtlxФ включены последовательно
//	tr0 = 1; // бит управлени€ таймера 0. устанавливаетс€/сбрасываетс€ программой дл€ пуска/останова таймера/счЄтчика
//	for (i = 0; i < 2 * x; i++) {
//		th0 = 0; // th0 - старший байт состо€нии€ таймера счечика tc0 (таймер счетчик 0)
//		tl0 = 0; // tl0 - младший байт таймера счетчика 
//		while (th0 < 20); // задержка в 50 мс (изначально было 195)
//	}
//}

void peredacha(char x) { // данна€ функци€ ѕ≈–≈ƒј≈“ —»ћ¬ќЋ
	SBUF = x; // заносим байт в буфер дл€ передачи
	while(!TI); // ждем пока отправитс€ из буфера в канал, ждем флаг
	TI = 0; // опускаем флаг дл€ последующей передачи байта
}


void main()
{
	const unsigned char* string;
	int i;
	PCON_BITS.B7 = 1; // SMOD = 1 по заданной частоте
	TMOD_BITS.B6 = 0; // 2 бит = 0, по таблице C/T0 = 0
	TMOD_BITS.B4 = 0; // M0 = 0
	TMOD_BITS.B5 = 1; // M1 = 1
	TH1 = 0x0FD; // по таблице 
	TR1 = 1; // включение таймера/счетчика

	SCON = 0; // занул€ем все настройки
	SCON_BITS.B4 = 0; // настройка приема (у нас не прием) 
	SCON_BITS.B5 = 1; // настройка передача
	SCON_BITS.B6 = 1; // настройка режима работы приема/передатчика K = 1 (SM1)
	SCON_BITS.B7 = 0; // настройка режима работы приема/передатчика K = 1 (SM0)
	string = "Simakhin Stepan"; // 15 байт максиум дл€ вывода  

	while (1) {
		for (i = 0; i < 15; i++) {
			peredacha(string[i]);
		}
	}

}
