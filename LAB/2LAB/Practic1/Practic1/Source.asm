; 15 вариант
; X = AB7C   Переменные размещены 
; Y = C58E	 в памяти
; Z = ABCD	 один за другим

; В цикле обнулить в X, Y, Z биты 3, 5, 6, 10 (результат X',Y',Z')

; Вычислить M = (X' & Y') - ~Z'
; Если у мл.М четное количество единиц, то переход к п/п 1
; (R = M (> 6 > )), иначе переход к п/п 2 (R = M & F1F1)

; Если был перенос, то переход к АДР 1 (R + 1),
; иначе переход к АДР 2 (R or 1021)
 
.686
.model flat, stdcall
.stack 100h

.data
; задача переменных
x dw 0h;0AB7Ch ; AB7Ch == 43900 (10) == 1010101101111100b
y dw 0C58Eh ; C58Eh == 50574 (10) == 1100010110001110b
z dw 0ABCDh ; ABCDh == 43981 (10) == 1010101111001101b
summ dw 0 ; переменная для 3 задания, сумма единиц
 m dw 0 ; переменная для хранения ответа
.code
ExitProcess PROTO STDCALL :DWORD
Start:
; очистка регистров
xor eax, eax 
xor ebx, ebx
xor ecx, ecx
xor edx, edx

mov di, 01111101110010111b ; зарезервированный регистр для хранения маски


; обнуление в цикле X, Y, Z биты 3, 5, 6, 10 
mov cx, 3 ; число итераций цикла loop_s
mov eax, offset x ; offset - функция, передается адрес в котором хранится переменная, в данном случае х 
	loop_s:
	and [eax], di ; [] - обращение к тому, что хранится по этому адресу 
	inc eax ; inc - кароче + 1
	inc eax ; 2 раза используется, так как значение занимает 2 байта, для смещения на следующее число
	loop loop_s 


	; Вычислить M = (X' & Y') - ~Z' 2 задание
	mov ax, x
	and ax, y
	not z ; побитовое инвертирование переменной z, что и имелось в задании (~Z')
	sub ax, z
	mov m, ax  ; сохранение ответа
	mov cx, 8 ; количество итераций для цикла loop_ass, 8 так как необходимо анализировать младший байт (8 бит)
	loop_ass:
	bt eax, 0 ; заносит во флаг CF = 1, если была 1, 0 если 0 (в регистрах флаг отображается как CY) анализирует младший бит переменной eax
	jc one ; перенос на one , если CF = 1
	jnc zero ; перенос на zero , если CF = 0
	one:
		ADD summ, 1
	zero:

	sar eax, 1 ; арифметический побитовый сдвиг (откидывает мл. бит, сохраняя старшие) вправо на 1 бит
	 
	loop loop_ass 
	; 00101100 10001010 , должно насчитать 3 единицы 
	
	bt summ, 0 ; заносит во флаг CF = 1, если была 1, 0 если 0 (в регистрах флаг отображается как CY) анализирует младший бит переменной summ
	jc odin ; перенос на odin , если CF = 1 => нечетное
	jnc nol ; перенос на nol , если CF = 0 => четное
	odin:
	mov ax, m 
	and ax, 0F1F1h
	jmp point ; точка для переноса, дабы не заходил в точку nol
	nol:
	mov ax, m 
	ror ax, 6 ; циклический сдвиг вправо 6 раз
	point:


	; 3 задание , cf - флаг переноса
	mov m, ax ; теперь в переменной m хранится значение R 
	jc first
	jnc second

	function_first PROC ; начало функции
		ADD m, 1
		ret ; return
	function_first ENDP ; конец функции

	function_second PROC ; начало функции
		or m, 1021
		ret ; return
	function_second ENDP ; конец функции

	first:
	call function_first
	jmp point_2 ; ; точка для переноса, дабы не заходил в точку second
	second:
	call function_second
	point_2:

exit:
Invoke ExitProcess,1
End Start